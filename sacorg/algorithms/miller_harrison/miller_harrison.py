from sacorg.utils import *
from sacorg.algorithms.isbigraphic import *


def N_count(p, conj_q, i, j, row_sum, submatrix_count_values):
    """
    Computes the number of binary matrices with margin sums (p,q)
    :param p: Row sum vector
    :param conj_q: Conjugate of the column vector q
    :param i: Row index
    :param j: Column index
    :param row_sum: Sum of the chosen row entries up to (i-1)th coordinate
    :param submatrix_count_values: Lookup table storing intermediate results
    :return total: The number of binary matrix with row and column sums p, q
    """
    total = 0
    if len(p) == i:
        return 1
    else:
        if p[i] == row_sum:
            # Store submatrix counts to avoid from computing them each time
            count_inx = tuple(conj_q)
            if count_inx in submatrix_count_values:
                return submatrix_count_values[count_inx]

            total = N_count(p, conj_q, i + 1, 0, 0, submatrix_count_values)
            submatrix_count_values[count_inx] = total

            return total

        else:
            # Construct the vector of counts, r, from conjugate partition of q
            r = np.asarray([conj_q[inx - 1] - conj_q[inx] for inx in np.arange(1, len(conj_q))] + [conj_q[-1]])

            # Determine lower bound for the entry in ith row and jth column
            lower_bound = max(0, p[i] - row_sum - conj_q[j + 1])
            # Determine upper bound for the entry in ith row and jth column
            gale_ryser_condition = np.sum(conj_q[0:j + 1]) - np.sum(p[i + 1:(i + 1) + j + 1])
            upper_bound = min(min(r[j], p[i] - row_sum), gale_ryser_condition)

            # Choose a value between bounds
            for s in range(lower_bound, upper_bound + 1):
                conj_q[j] -= s
                total += binomial(r[j], s) * N_count(p, conj_q, i, j + 1, row_sum + s, submatrix_count_values)
                conj_q[j] += s

            return total


def N_sample(p, conj_q, i, j, row_sum, sample_matrix, num_of_matrices, submatrix_count_values):
    """
    Generates a uniformly distributed sample satisfying margins (p, q_vect_counts)
    :param p: Row sum vector
    :param conj_q: Column sum vector
    :param i: Row index
    :param j: Column index
    :param row_sum: Sum of the chosen row entries up to (i-1)th coordinate
    :param sample_matrix: Constructed sample matrix with row and column sums (p, q_vect_counts)
    :param num_of_matrices: The number of matrices for the remaining submatrix
    :param submatrix_count_values: Lookup table storing intermediate results
    """

    if len(p) == i:
        return
    else:
        if p[i] == row_sum:

            N_sample(p, conj_q.copy(), i + 1, 0, 0, sample_matrix, num_of_matrices, submatrix_count_values)

        else:
            # Construct the vector of counts, r, from conjugate partition of q
            r = np.asarray([conj_q[inx - 1] - conj_q[inx] for inx in np.arange(1, len(conj_q))] + [conj_q[-1]])

            # Determine lower bound for the entry in ith row and jth column
            lower_bound = max(0, p[i] - row_sum - conj_q[j + 1])
            # Determine upper bound for the entry in ith row and jth column
            gale_ryser_condition = np.sum(conj_q[0:j + 1]) - np.sum(p[i + 1:(i + 1) + j + 1])
            upper_bound = min(min(r[j], p[i] - row_sum), gale_ryser_condition)
            # Sample uniformly from the set {0,1,...,num_of_matrices-1}
            random_number = np.random.randint(num_of_matrices, dtype=np.int64)

            # Choose a value between bounds
            total = 0
            for s in range(lower_bound, upper_bound + 1):
                conj_q[j] -= s
                value = N_count(p, conj_q.copy(), i, j + 1, row_sum + s, submatrix_count_values)
                total += binomial(r[j], s) * value

                if total > random_number:
                    sample_matrix[i][j] = s
                    N_sample(p, conj_q.copy(), i, j + 1, row_sum + s, sample_matrix, value, submatrix_count_values)
                    conj_q[j] += s
                    return

                conj_q[j] += s

            raise Warning("Algorithm must not reach this line! Check the error!")


def convert2binary(n, m, q, matrix_s):
    """
    Converts the matrix generated by N_sample function to a binary matrix
    :param n: Number of rows
    :param m: Number of columns
    :param q: Column sum
    :param matrix_s:
    :return binary_matrix: A binary matrix corresponding to N-valued (p, q_vect_counts)
    """

    # Copy the column sum q
    column_sum = np.asarray(q).copy()

    binary_matrix = np.zeros((n, m), dtype=np.int)
    for i in range(n):
        for j in range(max(q)):
            if matrix_s[i][j] > 0:
                indices = np.where(column_sum == j + 1)[0]
                # Randomly choose indices
                choosen_indices = np.random.choice(indices, matrix_s[i][j], replace=False)
                column_sum[choosen_indices] -= 1
                binary_matrix[i][choosen_indices] = 1

    return binary_matrix


def count(p, q, verbose=False):
    """
    Counts the number of binary matrices satisfying the margin sums (p,q)
    :param p: Row sum sequence
    :param q: Column sum sequence
    :return result: Number of binary matrices satisfying given margins
    """

    # Copy the sequences
    p_copy, q_copy = p.copy(), q.copy()

    # Get initial time
    time_start = time.clock()

    # If the sequences are empty, return 1
    if len(p_copy) == 0 and len(q_copy) == 0:
        if verbose is True:
            # Get the total computation time
            time_elapsed = (time.clock() - time_start)
            print "Total computation time : " + str(time_elapsed)
        return 1

    # If given margin sums are not bigraphic
    if is_bigraphic(p_copy, q_copy) is False:
        if verbose is True:
            # Get the total computation time
            time_elapsed = (time.clock() - time_start)
            print "Total computation time : " + str(time_elapsed)
        return 0

    # If the length of the sequence p is larger than q, than switch the sequences
    if len(q_copy) > len(p_copy):
        temp = p_copy
        p_copy = q_copy
        q_copy = temp

    # Find the conjugate of q and append 0 to avoid from index exceeding problem
    q_conj = conjugate(q_copy)
    q_conj = np.append(q_conj, 0)

    # Sort p in descending order
    p_copy = np.sort(p_copy)[::-1]

    # Store subMatrix counts to avoid from computing them again
    submatrix_count_values = {}

    result = N_count(p_copy, q_conj.copy(), i=0, j=0, row_sum=0, submatrix_count_values=submatrix_count_values)
    return result


def get_sample(p, q, num_of_samples, verbose=False):
    """
    Uniformly generates a binary matrix satisfying the row and column sums (p,q)
    :param p: Row sum sequence
    :param q: Column sum sequence
    :param num_of_samples: Number of samples that will be generated
    :return samples: Binary samples
    """

    # Copy the sequences
    p_copy, q_copy = p.copy(), q.copy()

    # Get initial time
    time_start = time.clock()

    # If the sequence is empty or is not graphical
    if (len(p_copy) == 0 and len(q_copy) == 0) or is_bigraphic(p_copy, q_copy) is False:
        if verbose is True:
            # Get the total computation time
            time_elapsed = (time.clock() - time_start)
            print "Total computation time : " + str(time_elapsed)
        return []

    # The length of p should be larger than q, otherwise switch p and q
    transposed = False
    if len(q_copy) > len(p_copy):
        temp = p_copy
        p_copy = q_copy
        q_copy = temp
        transposed = True

    # Store the sorted indices
    inx_order1, inx_order2 = np.argsort(p_copy), np.argsort(q_copy)
    inx_order1, inx_order2 = inx_order1[::-1], inx_order2[::-1]
    inx_order1, inx_order2 = np.argsort(inx_order1), np.argsort(inx_order2)
    # Sort sequences in descending order to increase the performance
    p_copy, q_copy = np.sort(p_copy)[::-1], np.sort(q_copy)[::-1]

    # Find the conjugate of q and append 0 to avoid from index exceeding problem
    q_conj = conjugate(q_copy)
    q_conj = np.append(q_conj, 0)
    # Store subMatrix counts to avoid from computing them again
    submatrix_count_values = {}
    # Compute the number of matrices satisfying the margins p,q
    num_of_matrices = N_count(p_copy, q_conj, i=0, j=0, row_sum=0, submatrix_count_values=submatrix_count_values)

    edges = []
    for k in range(num_of_samples):

        sample_matrix_s = np.zeros((len(p_copy), max(q_copy)), dtype=np.int)
        N_sample(p_copy, q_conj, 0, 0, 0, sample_matrix_s, num_of_matrices, submatrix_count_values)

        m = convert2binary(len(p_copy), len(q_copy), q_copy, sample_matrix_s)
        m = m[inx_order1, :][:, inx_order2]
        if transposed is True:
            m = np.asarray(m).T

        #matrices.append(m)
        e = matrix2edges(m, "bipartite")
        edges.append(e)

    # Get the total computation time
    time_elapsed = (time.clock() - time_start)
    if verbose is True:
        print "Total computation time : " + str(time_elapsed)
        print str(len(edges)) + " valid samples were generated out of " + str(num_of_samples) + " trials."

    #return matrices
    return edges