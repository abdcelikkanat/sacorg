from sacorg.utils import *
from sacorg.algorithms.isgraphical import *


def s(deg_seq):
    """
    Generates a sample graph for a given degree sequence d
    :param deg_seq: Given degree sequence
    :return E, p, c:  edges with vertex labels starting from 1,
                      probability of the generated graph and
                      the number of edge combinations
    """
    # Copy the given degree sequence to use it as residual sequence
    r = deg_seq.copy()

    p = 1.0  # probability of the generated graph
    c = 1  # the number of edge combinations for the same graph that can be generated by the algorithm

    E = []  # list of edges
    N = len(r)  # length of the sequence

    adjacentVertices = [[] for _ in range(N)]  # stores the vertices which are adjacent

    # run until residual sequence completely becomes 0 vector
    while np.any(r != 0):

        # Get the index of vertex having minimum degree greater than 0
        i = np.where(r == np.amin(r[r > 0]))[0][-1]

        c *= factorial(r[i])

        while r[i] != 0:
            J = np.asarray([], dtype=np.int)  # Construct candidate list J

            possibleVertices = [o for o in np.arange(N) if (r[o] > 0 and o != i and (o not in adjacentVertices[i]))]
            for j in possibleVertices:
                # Decrease degrees by one
                (r[i], r[j]) = (r[i] - 1, r[j] - 1)
                # add the the vertex j to candidate list J, if residual sequence is graphical
                if is_graphical(r):
                    J = np.append(J, j)
                # Increase degrees by one
                (r[i], r[j]) = (r[i] + 1, r[j] + 1)

            # Pick a vertex j in the candidate list J with probability proportional to its degree d_j
            degrees = np.asarray([r[u] for u in J])
            prob = degrees / float(np.sum(degrees))
            j = np.random.choice(J, p=prob, size=1)[0]
            # Add the found edge to the edge lists
            if i < j:
                E.append([i + 1, j + 1])  # indices start from 1
            else:
                E.append([j + 1, i + 1])  # indices start from 1
            # Add the chosen vertex to the list in order to not choose it again
            adjacentVertices[i].append(j)
            # Decrease degrees by 1
            (r[i], r[j]) = (r[i] - 1, r[j] - 1)
            p *= prob[J == j][0]

    # Sort the edge sequences
    E.sort()
    return E, p, c


def get_sample(deg_seq, num_of_samples, verbose=False):
    """
    Generates graphs realizing the degree sequence 'deg_seq' with vertex labels {1,...,len(deg_seq}}
    :param deg_seq: Degree sequence
    :param num_of_samples: Number of samples which will be generated
    :return:
    """
    # Get the initial time
    time_start = time.clock()

    # If the sequence is empty or is not graphical
    if len(deg_seq) == 0 or is_graphical(deg_seq) is False:
        if verbose is True:
            # Get the total computation time
            time_elapsed = (time.clock() - time_start)
            print "Total computation time : " + str(time_elapsed)
        return []

    edges = []
    for _ in range(num_of_samples):
        # Call the s function
        e, p, c = s(deg_seq)
        # Append the edges
        edges.append(e)

    # Get the total computation time
    time_elapsed = (time.clock() - time_start)

    if verbose is True:
        print "Total computation time : " + str(time_elapsed)

    # Return the edges
    return edges


def count(deg_seq, num_of_samples=1000, verbose=False):
    """
    Estimates the number of graphs satisfying the degree sequence
    :param deq_seq: Degree sequence
    :param num_of_samples: number of samples used in estimation
    :return estimation, std: Estimation for the number of graphs satisfying the given degree sequence d
                             and standard deviation
    """
    estimate = 0.0

    # Get initial time
    time_start = time.clock()

    # If the sequence is empty or is not graphical
    if len(deg_seq) == 0 or is_graphical(deg_seq) is False:
        if verbose is True:
            # Get the total computation time
            time_elapsed = (time.clock() - time_start)
            print "Total computation time : " + str(time_elapsed)
        return 0.0, 0.0

    weights = np.zeros(num_of_samples, dtype=float)

    for i in range(num_of_samples):
        (edges, p, c) = s(deg_seq)
        weights[i] = 1.0 / float(c * p)

    estimate = (1.0 / float(num_of_samples)) * np.sum(weights)
    std = np.std(weights, ddof=1)

    # Get the total computation time
    time_elapsed = (time.clock() - time_start)
    if verbose is True:
        print "Total computation time : " + str(time_elapsed)

    return estimate, std